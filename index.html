<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tages-Tracking</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="bg-slate-100 p-4">
  <div class="max-w-5xl mx-auto space-y-6">
    <header class="flex items-start justify-between gap-4">
      <div>
        <h1 class="text-2xl font-bold text-slate-900">Tages-Tracking</h1>
        <p class="text-sm text-slate-600">Werte (1–10) + Ängste pro Tag, persistent via localStorage.</p>
      </div>
    </header>

    <!-- ====================== Eingabe ====================== -->
    <section class="bg-white rounded-xl shadow-sm border border-slate-200 p-4 space-y-4">
      <div class="flex flex-wrap gap-4 items-end">
        <div>
          <label for="dateInput" class="block text-sm font-medium text-slate-700">Datum</label>
          <input id="dateInput" type="date" class="mt-1 w-44 rounded-md border-slate-300 focus:border-blue-500 focus:ring-blue-500" />
        </div>

        <div>
          <label for="morning" class="block text-sm font-medium text-slate-700">Morgens</label>
          <select id="morning" class="mt-1 w-56 rounded-md border-slate-300 focus:border-blue-500 focus:ring-blue-500"></select>
        </div>

        <div>
          <label for="noon" class="block text-sm font-medium text-slate-700">Mittags</label>
          <select id="noon" class="mt-1 w-56 rounded-md border-slate-300 focus:border-blue-500 focus:ring-blue-500"></select>
        </div>

        <div>
          <label for="evening" class="block text-sm font-medium text-slate-700">Abends</label>
          <select id="evening" class="mt-1 w-56 rounded-md border-slate-300 focus:border-blue-500 focus:ring-blue-500"></select>
        </div>
      </div>

      <!-- Ängste Counter -->
      <div class="flex flex-wrap items-center gap-3">
        <div class="text-sm font-medium text-slate-700">Ängste</div>
        <button id="minusAnx" class="px-3 py-1 rounded-md border border-slate-300 bg-slate-50 hover:bg-slate-100">−</button>
        <div id="anxValue" class="min-w-10 text-center font-semibold text-slate-900">0</div>
        <button id="plusAnx" class="px-3 py-1 rounded-md border border-slate-300 bg-slate-50 hover:bg-slate-100">+</button>

        <div class="grow"></div>

        <button id="saveBtn" class="px-4 py-2 rounded-md bg-blue-600 hover:bg-blue-700 text-white font-medium">
          Speichern
        </button>
        <button id="deleteBtn" class="px-4 py-2 rounded-md bg-slate-200 hover:bg-slate-300 text-slate-900 font-medium">
          Tag löschen
        </button>
        <button id="refreshChartsBtn" class="px-4 py-2 rounded-md bg-slate-900 hover:bg-black text-white font-medium">
          Diagramme aktualisieren
        </button>
      </div>

      <div id="status" class="text-sm text-slate-600"></div>
    </section>

    <!-- ====================== Diagramm 1 ====================== -->
    <details open class="bg-white rounded-xl shadow-sm border border-slate-200 p-4">
      <summary class="cursor-pointer select-none font-semibold text-slate-900">
        Diagramm 1 – Werte (morgens/mittags/abends + Durchschnitt)
      </summary>

      <div class="mt-3 flex flex-wrap items-center gap-4 text-sm text-slate-700">
        <label class="inline-flex items-center gap-2">
          <input type="checkbox" class="rounded border-slate-300" data-series="morning" checked />
          <span>Morgen (rot)</span>
        </label>
        <label class="inline-flex items-center gap-2">
          <input type="checkbox" class="rounded border-slate-300" data-series="noon" checked />
          <span>Mittag (blau)</span>
        </label>
        <label class="inline-flex items-center gap-2">
          <input type="checkbox" class="rounded border-slate-300" data-series="evening" checked />
          <span>Abend (grün)</span>
        </label>
        <label class="inline-flex items-center gap-2">
          <input type="checkbox" class="rounded border-slate-300" data-series="average" checked />
          <span>Durchschnitt (schwarz)</span>
        </label>
      </div>

      <div class="mt-4">
        <canvas id="valuesChart" width="980" height="420" class="w-full border border-slate-200 rounded-lg bg-white"></canvas>
      </div>
      <p class="mt-2 text-xs text-slate-500">Y-Achse fest 1–10 · X-Achse Datum (chronologisch)</p>
    </details>

    <!-- ====================== Diagramm 2 ====================== -->
    <details open class="bg-white rounded-xl shadow-sm border border-slate-200 p-4">
      <summary class="cursor-pointer select-none font-semibold text-slate-900">
        Diagramm 2 – Ängste pro Tag (Linie + Marker)
      </summary>
      <p class="mt-2 text-sm text-slate-600">
        Liniendiagramm, weil der zeitliche Verlauf der Angst-Intensität relevant ist. Jeder Tag wird zusätzlich durch einen Marker (Punkt) markiert.
      </p>

      <div class="mt-4">
        <canvas id="anxChart" width="980" height="320" class="w-full border border-slate-200 rounded-lg bg-white"></canvas>
      </div>
      <p class="mt-2 text-xs text-slate-500">Y-Achse ab 0, automatisch skaliert (niemals degeneriert)</p>
    </details>

    <!-- Mini-Tabelle (optional, hilft beim Debuggen) -->
    <section class="bg-white rounded-xl shadow-sm border border-slate-200 p-4">
      <h2 class="font-semibold text-slate-900">Gespeicherte Tage</h2>
      <div id="tableWrap" class="mt-3 text-sm text-slate-700"></div>
    </section>

  </div>

<script>
/* ============================================================
 * 1) Konstanten: Labels & Farben (fix)
 * ============================================================ */
const VALUE_LABELS = {
  1:"sehr schlecht", 2:"schlecht", 3:"sehr unzufrieden", 4:"unzufrieden", 5:"neutral",
  6:"eher zufrieden", 7:"zufrieden", 8:"gut", 9:"sehr gut", 10:"ausgezeichnet"
};

const SERIES_COLORS = {
  morning: "red",
  noon: "blue",
  evening: "green",
  average: "black" // fest definiert
};

const ANX_COLOR = "#6d28d9"; // violett (fest)

/* ============================================================
 * 2) DOM-Handling
 * ============================================================ */
const dom = {
  dateInput: document.getElementById("dateInput"),
  morning: document.getElementById("morning"),
  noon: document.getElementById("noon"),
  evening: document.getElementById("evening"),
  anxValue: document.getElementById("anxValue"),
  plusAnx: document.getElementById("plusAnx"),
  minusAnx: document.getElementById("minusAnx"),
  saveBtn: document.getElementById("saveBtn"),
  deleteBtn: document.getElementById("deleteBtn"),
  refreshChartsBtn: document.getElementById("refreshChartsBtn"),
  status: document.getElementById("status"),
  valuesChart: document.getElementById("valuesChart"),
  anxChart: document.getElementById("anxChart"),
  tableWrap: document.getElementById("tableWrap"),
};

function setStatus(msg) {
  dom.status.textContent = msg;
}

function buildSelectOptions(selectEl) {
  selectEl.innerHTML = "";
  const ph = document.createElement("option");
  ph.value = "";
  ph.textContent = "Bitte wählen…";
  selectEl.appendChild(ph);

  for (let i = 1; i <= 10; i++) {
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = `${i} – ${VALUE_LABELS[i]}`;
    selectEl.appendChild(opt);
  }
}

/* ============================================================
 * 3) Datenlogik: localStorage
 *    Key: YYYY-MM-DD
 *    Value: { morning, noon, evening, anxieties }
 * ============================================================ */
const Storage = {
  isIsoDateKey(k) { return /^\d{4}-\d{2}-\d{2}$/.test(k); },

  loadDay(date) {
    const raw = localStorage.getItem(date);
    if (!raw) return null;
    try { return JSON.parse(raw); } catch { return null; }
  },

  saveDay(date, obj) {
    localStorage.setItem(date, JSON.stringify(obj));
  },

  deleteDay(date) {
    localStorage.removeItem(date);
  },

  loadAllDays() {
    const keys = [];
    for (let i = 0; i < localStorage.length; i++) {
      const k = localStorage.key(i);
      if (this.isIsoDateKey(k)) keys.push(k);
    }
    keys.sort();
    return keys
      .map(date => ({ date, ...this.loadDay(date) }))
      .filter(row => row && this.isValidRow(row));
  },

  isValidRow(row) {
    // Tag gilt nur als gültig, wenn morning/noon/evening gesetzt (1..10)
    return this.isValidValue(row.morning) &&
           this.isValidValue(row.noon) &&
           this.isValidValue(row.evening) &&
           this.isValidAnx(row.anxieties);
  },

  isValidValue(v) { return Number.isInteger(v) && v >= 1 && v <= 10; },
  isValidAnx(v)   { return Number.isInteger(v) && v >= 0; },
};

/* ============================================================
 * 4) UI <-> Daten: Laden / Setzen
 * ============================================================ */
function todayIso() {
  const d = new Date();
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");
  return `${yyyy}-${mm}-${dd}`;
}

function getUiModel() {
  const date = dom.dateInput.value;
  const morning = Number(dom.morning.value);
  const noon = Number(dom.noon.value);
  const evening = Number(dom.evening.value);
  const anxieties = Number(dom.anxValue.textContent);

  return { date, morning, noon, evening, anxieties };
}

function setUiFromModel(model) {
  dom.morning.value = model?.morning ? String(model.morning) : "";
  dom.noon.value = model?.noon ? String(model.noon) : "";
  dom.evening.value = model?.evening ? String(model.evening) : "";
  dom.anxValue.textContent = String(model?.anxieties ?? 0);
}

function onDateChange() {
  const date = dom.dateInput.value;
  if (!date) return;

  const existing = Storage.loadDay(date);
  if (existing) {
    setUiFromModel(existing);
    setStatus(`Geladen: ${date}`);
  } else {
    setUiFromModel({ anxieties: 0 });
    setStatus(`Neuer Tag: ${date}`);
  }
}

/* ============================================================
 * 5) Diagramm-Rendering (Canvas)
 *    - Diagramm 1: 1..10, 4 Serien, Checkboxen
 *    - Diagramm 2: Ängste, auto-scale, Marker pro Punkt
 * ============================================================ */
const Charts = {
  // generischer Renderer für Linien + optional Marker
  drawLineChart(canvas, cfg) {
    const ctx = canvas.getContext("2d");
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0, 0, W, H);

    const { labels, series, yMin, yMax, showMarkers, markerRadius } = cfg;

    if (!labels || labels.length === 0 || !series || series.length === 0) {
      this.drawEmpty(ctx, W, H, "Keine Daten vorhanden.");
      return;
    }

    // Robust: niemals degenerierte Skala
    const safeRange = Math.max(1, yMax - yMin);

    const padL = 64, padR = 16, padT = 18, padB = 56;
    const plotW = W - padL - padR;
    const plotH = H - padT - padB;

    const n = labels.length;
    const xAt = (i) => (n === 1)
      ? padL + plotW / 2
      : padL + (i * plotW) / (n - 1);

    const yAt = (v) => {
      const t = (v - yMin) / safeRange;
      return padT + (1 - t) * plotH;
    };

    // Hintergrund
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(padL, padT, plotW, plotH);

    // Grid + Achsen
    this.drawAxes(ctx, { padL, padT, plotW, plotH, yMin, yMax, labels });

    // Linien zeichnen
    for (const s of series) {
      ctx.save();
      ctx.strokeStyle = s.color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      s.data.forEach((v, i) => {
        const x = xAt(i);
        const y = yAt(v);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
      ctx.restore();

      // Marker (Punkte) optional
      if (showMarkers) {
        ctx.save();
        ctx.fillStyle = s.markerColor ?? s.color;
        const r = markerRadius ?? 4;
        s.data.forEach((v, i) => {
          const x = xAt(i);
          const y = yAt(v);
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.restore();
      }
    }
  },

  drawAxes(ctx, a) {
    const { padL, padT, plotW, plotH, yMin, yMax, labels } = a;

    // horizontale Gridlines + Y Labels
    ctx.save();
    ctx.strokeStyle = "#e5e7eb"; // slate-200
    ctx.fillStyle = "#334155";   // slate-700
    ctx.font = "12px system-ui";
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";

    // Wir zeichnen sinnvolle Ticks:
    // - Für Werte-Chart 1..10: 1..10
    // - Für Ängste: 0..max (max <= 10?) -> wir nehmen bis zu 6 Ticks
    const ticks = this.computeTicks(yMin, yMax);
    for (const t of ticks) {
      const yy = padT + (1 - (t - yMin) / Math.max(1, yMax - yMin)) * plotH;
      ctx.beginPath();
      ctx.moveTo(padL, yy);
      ctx.lineTo(padL + plotW, yy);
      ctx.stroke();
      ctx.fillText(String(t), padL - 8, yy);
    }

    // Achsen
    ctx.strokeStyle = "#0f172a"; // slate-900
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padL, padT);
    ctx.lineTo(padL, padT + plotH);
    ctx.lineTo(padL + plotW, padT + plotH);
    ctx.stroke();

    // X Labels (ausgedünnt)
    const n = labels.length;
    const maxLabels = 10;
    const step = Math.max(1, Math.ceil(n / maxLabels));

    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillStyle = "#334155";
    for (let i = 0; i < n; i += step) {
      const x = (n === 1) ? (padL + plotW / 2) : (padL + (i * plotW) / (n - 1));
      const lab = labels[i];
      // Tick
      ctx.beginPath();
      ctx.moveTo(x, padT + plotH);
      ctx.lineTo(x, padT + plotH + 5);
      ctx.strokeStyle = "#0f172a";
      ctx.stroke();
      ctx.fillText(lab, x, padT + plotH + 8);
    }

    ctx.restore();
  },

  computeTicks(min, max) {
    // Für min=1,max=10: 1..10
    if (min === 1 && max === 10) return Array.from({length:10}, (_,i)=>i+1);

    // Sonst: bis zu 6 Ticks, ganzzahlig
    const range = Math.max(1, max - min);
    const steps = Math.min(6, range + 1);
    const stepSize = Math.max(1, Math.round(range / (steps - 1)));

    const out = [];
    let v = min;
    while (v < max) {
      out.push(Math.round(v));
      v += stepSize;
    }
    out.push(Math.round(max));
    // Duplikate entfernen
    return [...new Set(out)];
  },

  drawEmpty(ctx, W, H, msg) {
    ctx.save();
    ctx.fillStyle = "#334155";
    ctx.font = "14px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(msg, W / 2, H / 2);
    ctx.restore();
  },

  renderAll() {
    const rows = Storage.loadAllDays();
    if (rows.length === 0) {
      this.drawLineChart(dom.valuesChart, { labels: [], series: [], yMin: 1, yMax: 10 });
      this.drawLineChart(dom.anxChart, { labels: [], series: [], yMin: 0, yMax: 1 });
      return;
    }

    const labels = rows.map(r => r.date);

    // Diagramm 1: 4 Serien + Checkbox Filter
    const enabled = {};
    document.querySelectorAll("input[data-series]").forEach(cb => {
      enabled[cb.dataset.series] = cb.checked;
    });

    const base = {
      morning: rows.map(r => r.morning),
      noon: rows.map(r => r.noon),
      evening: rows.map(r => r.evening),
      average: rows.map(r => (r.morning + r.noon + r.evening) / 3),
    };

    const series1 = Object.keys(base)
      .filter(k => enabled[k])
      .map(k => ({ data: base[k], color: SERIES_COLORS[k] }));

    this.drawLineChart(dom.valuesChart, {
      labels,
      series: series1,
      yMin: 1,
      yMax: 10,
      showMarkers: false
    });

    // Diagramm 2: Ängste (Linie + Marker)
    const anx = rows.map(r => r.anxieties ?? 0);
    const anxMax = Math.max(...anx, 0);
    // Robust: niemals degeneriert => yMax > yMin
    const yMin = 0;
    const yMax = Math.max(1, anxMax + 1);

    this.drawLineChart(dom.anxChart, {
      labels,
      series: [{
        data: anx,
        color: ANX_COLOR,
        markerColor: ANX_COLOR
      }],
      yMin,
      yMax,
      showMarkers: true,
      markerRadius: 4
    });
  }
};

/* ============================================================
 * 6) Aktionen: Save / Delete / Counter
 * ============================================================ */
function validateDayModel(model) {
  // model.morning/noon/evening müssen 1..10 sein
  return Storage.isValidValue(model.morning) &&
         Storage.isValidValue(model.noon) &&
         Storage.isValidValue(model.evening) &&
         Storage.isValidAnx(model.anxieties);
}

function onSave() {
  const m = getUiModel();
  if (!m.date) return setStatus("Fehler: Kein Datum gewählt.");

  if (!validateDayModel(m)) {
    setStatus("Fehler: Bitte morning/noon/evening (1–10) setzen. Ängste >= 0.");
    return;
  }

  Storage.saveDay(m.date, {
    morning: m.morning,
    noon: m.noon,
    evening: m.evening,
    anxieties: m.anxieties
  });

  setStatus(`Gespeichert: ${m.date}`);
  renderTable();
  Charts.renderAll();
}

function onDelete() {
  const date = dom.dateInput.value;
  if (!date) return setStatus("Fehler: Kein Datum gewählt.");
  Storage.deleteDay(date);
  setUiFromModel({ anxieties: 0 });
  setStatus(`Gelöscht: ${date}`);
  renderTable();
  Charts.renderAll();
}

function onPlusAnx() {
  const v = Number(dom.anxValue.textContent);
  dom.anxValue.textContent = String(v + 1);
}

function onMinusAnx() {
  const v = Number(dom.anxValue.textContent);
  dom.anxValue.textContent = String(Math.max(0, v - 1));
}

/* ============================================================
 * 7) Tabelle (hilft beim Prüfen)
 * ============================================================ */
function renderTable() {
  const rows = Storage.loadAllDays();
  if (rows.length === 0) {
    dom.tableWrap.innerHTML = "<div class='text-slate-500'>Keine gespeicherten Tage.</div>";
    return;
  }

  let html = `
    <div class="overflow-auto">
      <table class="min-w-full border-separate border-spacing-0">
        <thead>
          <tr class="text-left text-slate-600">
            <th class="py-2 pr-4 border-b">Datum</th>
            <th class="py-2 pr-4 border-b">Morgens</th>
            <th class="py-2 pr-4 border-b">Mittags</th>
            <th class="py-2 pr-4 border-b">Abends</th>
            <th class="py-2 pr-4 border-b">Ängste</th>
          </tr>
        </thead>
        <tbody class="text-slate-800">
  `;
  for (const r of rows) {
    html += `
      <tr>
        <td class="py-2 pr-4 border-b">${r.date}</td>
        <td class="py-2 pr-4 border-b">${r.morning}</td>
        <td class="py-2 pr-4 border-b">${r.noon}</td>
        <td class="py-2 pr-4 border-b">${r.evening}</td>
        <td class="py-2 pr-4 border-b">${r.anxieties}</td>
      </tr>
    `;
  }
  html += "</tbody></table></div>";
  dom.tableWrap.innerHTML = html;
}

/* ============================================================
 * 8) Events & Init
 * ============================================================ */
function init() {
  buildSelectOptions(dom.morning);
  buildSelectOptions(dom.noon);
  buildSelectOptions(dom.evening);

  dom.dateInput.value = todayIso();
  dom.dateInput.addEventListener("change", onDateChange);

  dom.plusAnx.addEventListener("click", onPlusAnx);
  dom.minusAnx.addEventListener("click", onMinusAnx);

  dom.saveBtn.addEventListener("click", onSave);
  dom.deleteBtn.addEventListener("click", onDelete);
  dom.refreshChartsBtn.addEventListener("click", () => Charts.renderAll());

  // Checkboxen -> Neurender
  document.querySelectorAll("input[data-series]").forEach(cb => {
    cb.addEventListener("change", () => Charts.renderAll());
  });

  onDateChange();
  renderTable();
  Charts.renderAll();
}

init();
</script>
</body>
</html>